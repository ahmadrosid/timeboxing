This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-16T10:02:33.436Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
lib/
  components/
    ActiveTask.svelte
    Dropdown.svelte
    TaskForm.svelte
    TaskItem.svelte
  index.ts
routes/
  +layout.svelte
  +page.svelte
app.css
app.d.ts
app.html

================================================================
Repository Files
================================================================

================
File: lib/components/ActiveTask.svelte
================
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import Play from "lucide-svelte/icons/play";
  import Pause from "lucide-svelte/icons/pause";
  
  export let activeTask;
  export let timeLeft: number;
  export let isRunning: boolean;
  export let toggleTimer;

  let lastUpdateTime: number;
  let animationFrameId: number;

  $: minutes = Math.floor(timeLeft / 60);
  $: remainingSeconds = timeLeft % 60;
  $: progress = (1 - timeLeft / (activeTask.duration * 60)) * 100;

  function updateTimer() {
    if (isRunning) {
      const now = Date.now();
      const delta = (now - lastUpdateTime) / 1000;
      timeLeft = Math.max(0, timeLeft - delta);
      lastUpdateTime = now;
    }
    
    if (timeLeft > 0 && isRunning) {
      animationFrameId = requestAnimationFrame(updateTimer);
    }
  }

  function handleVisibilityChange() {
    if (!document.hidden && isRunning) {
      lastUpdateTime = Date.now();
      updateTimer();
    }
  }

  onMount(() => {
    lastUpdateTime = Date.now();
    document.addEventListener('visibilitychange', handleVisibilityChange);
    updateTimer();
  });

  onDestroy(() => {
    document.removeEventListener('visibilitychange', handleVisibilityChange);
    cancelAnimationFrame(animationFrameId);
  });
</script>

<div class="mb-6 p-4 rounded-lg shadow-lg bg-white border border-gray-500">
  <h2 class="text-2xl font-semibold mb-4">{activeTask.name}</h2>
  <div class="text-4xl font-bold mb-4">
    {String(Math.floor(minutes)).padStart(2, "0")}:{String(Math.floor(remainingSeconds)).padStart(2, "0")}
  </div>
  <div class="mb-4">
    <div class="w-full h-2 bg-gray-200 rounded-full">
      <div
        class="h-2 bg-black rounded-full"
        style="width: {progress}%;"
      ></div>
    </div>
  </div>
  <div>
    <button
      on:click={toggleTimer}
      class="w-full py-2 px-4 mt-4 rounded-lg font-semibold text-white bg-black hover:bg-gray-700 transition duration-300 flex items-center justify-center"
    >
      {#if isRunning}
        <Pause class="h-4 w-4 mr-2" /> Pause
      {:else}
        <Play class="h-4 w-4 mr-2" /> Resume
      {/if}
    </button>
  </div>
</div>

================
File: lib/components/Dropdown.svelte
================
<script lang="ts">
  import { createEventDispatcher, onMount } from "svelte";

  export let options: string[] = [];
  export let selectedOption: string = "";

  let isOpen: boolean = false;
  let dropdownRef: HTMLElement;

  const dispatch = createEventDispatcher<{
    select: string;
  }>();

  function toggleDropdown(): void {
    isOpen = !isOpen;
  }

  function selectOption(option: string): void {
    selectedOption = option;
    isOpen = false;
    dispatch("select", option);
  }

  function handleClickOutside(event: MouseEvent) {
    if (dropdownRef && !dropdownRef.contains(event.target as Node) && isOpen) {
      isOpen = false;
    }
  }

  function handleKeydown(event: KeyboardEvent) {
    if (event.key === "Escape" && isOpen) {
      isOpen = false;
    }
  }

  onMount(() => {
    document.addEventListener("click", handleClickOutside);
    document.addEventListener("keydown", handleKeydown);
    return () => {
      document.removeEventListener("click", handleClickOutside);
      document.removeEventListener("keydown", handleKeydown);
    };
  });
</script>

<div class="relative inline-block text-left" bind:this={dropdownRef}>
  <div>
    <button
      type="button"
      on:click={toggleDropdown}
      class="inline-flex items-center justify-center w-full pl-4 bg-transparent text-base pt-2 pr-1 focus:outline-none"
      aria-haspopup="true"
      aria-expanded={isOpen}
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        stroke-width="1.5"
        stroke="currentColor"
        class="size-4"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          d="M8.25 15 12 18.75 15.75 15m-7.5-6L12 5.25 15.75 9"
        />
      </svg>
    </button>
  </div>

  {#if isOpen}
    <div
      class="origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none"
      role="menu"
      aria-orientation="vertical"
      aria-labelledby="options-menu"
    >
      <div class="py-1" role="none">
        {#each options as option}
          <button
            on:click={() => selectOption(option)}
            class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900"
            role="menuitem"
          >
            {option}
          </button>
        {/each}
      </div>
    </div>
  {/if}
</div>

================
File: lib/components/TaskForm.svelte
================
<script lang="ts">
  import Dropdown from './Dropdown.svelte'; 
  interface Task {
    name: string;
    duration: number | null;
    id: number;
    description: string;
    status: 'todo' | 'in-progress' | 'paused' | 'done';
    date: string;
  }

  export let newTask: Task;
  export let addTask: () => void;
  export let exportTasks: () => void;
  export let importTasks: (event: Event) => void;

  let options: string[] = ['Export', 'Import'];
  let selectedOption = '';

  function handleSelect(event: CustomEvent<string>): void {
    const option = event.detail;
    if (option === 'Export') {
      exportTasks();
    } else if (option === 'Import') {
      const fileInput = document.getElementById('fileInput') as HTMLInputElement | null;
      if (fileInput) {
        fileInput.click();
      }
    }
  }

  function validateDuration(value: string): number {
    const parsedValue = parseInt(value, 10);
    return isNaN(parsedValue) || parsedValue < 0 ? 0 : parsedValue;
  }
  
</script>

<div class="mb-6 space-y-2">
  <div class="flex justify-between items-center mb-2">
    <h2 class="text-xl font-bold">Add New Task</h2>
    <div>
      <Dropdown {options} bind:selectedOption on:select={handleSelect} />
      <input 
        id="fileInput"
        type="file" 
        on:change={importTasks} 
        accept=".json" 
        class="hidden"
      />
    </div>
  </div>
  <div class="grid p-2 w-full border border-gray-500 bg-white rounded-lg">
    <input
      placeholder="Task name"
      bind:value={newTask.name}
      class="h-10 px-2 text-sm focus:outline-none"
    />
    <input
      placeholder="Duration (min)"
      type="number"
      bind:value={newTask.duration}
      on:input={(e) => newTask.duration = validateDuration(e.currentTarget.value)}
      class="h-10 px-2 rounded-lg text-sm focus:outline-none"
    />
    <div class="flex justify-end">
      <button
        on:click={addTask}
        class="text-xs bg-black hover:bg-gray-700 text-white font-bold py-2 px-3 rounded-lg flex items-center gap-2 justify-center"
      >Add Task
      </button>
    </div>
  </div>
</div>

================
File: lib/components/TaskItem.svelte
================
<script lang="ts">
    import { onMount } from 'svelte';
    import Play from "lucide-svelte/icons/play";
    import Pause from "lucide-svelte/icons/pause";
    import Trash2 from "lucide-svelte/icons/trash-2";
    import Check from "lucide-svelte/icons/check";

    interface Task {
        name: string;
        duration: number | null;
        id: number;
        description: string;
        status: 'todo' | 'in-progress' | 'paused' | 'done';
        date: string; // Optional date field
    }

    export let task: Task;
    export let startTask: (task: Task) => void;
    export let pauseTask: (task: Task) => void;
    export let deleteTask: (id: number) => void;
    export let markTaskAsDone: (task: Task) => void;

    let internalStatus: Task['status'];

    onMount(() => {
        internalStatus = task.status;
    });

    function handleStartTask(): void {
        internalStatus = 'in-progress';
        startTask(task);
    }

    function handlePauseTask(): void {
        internalStatus = 'paused';
        pauseTask(task);
    }

    function handleMarkAsDone(): void {
        internalStatus = 'done';
        markTaskAsDone(task);
    }

    $: formattedDate = new Date(task.date).toLocaleDateString(undefined, {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    });

    $: statusColor = {
        'todo': 'bg-gray-500',
        'in-progress': 'bg-blue-500',
        'paused': 'bg-yellow-500',
        'done': 'bg-green-500'
    }[internalStatus];
</script>

<div class="mb-4 p-4 rounded-lg shadow-lg bg-white border border-gray-500">
    <h3 class="font-semibold">{task.name}</h3>
    <div class="flex items-center justify-between pt-2">
        <div>
            <p class="text-sm text-gray-500">{formattedDate} - {task.duration} minutes</p>
            <p class="text-sm text-gray-500 pt-1">
                Status: 
                <span 
                    class="py-0.5 px-1 rounded-sm text-xs text-white {statusColor}"
                >
                    {internalStatus}
                </span>
            </p>
        </div>
        <div class="flex gap-1">
            {#if internalStatus === 'done'}
                <button disabled class="bg-transparent text-green-500 font-bold py-2 px-2 rounded">
                    <Check class="h-4 w-4" />
                </button>
            {:else if internalStatus === 'in-progress'}
                <button on:click={handlePauseTask} class="bg-transparent text-black font-bold py-2 px-2 rounded hover:text-yellow-500">
                    <Pause class="h-4 w-4" />
                </button>
                <button on:click={handleMarkAsDone} class="bg-transparent text-black font-bold py-2 px-2 rounded hover:text-green-500">
                    <Check class="h-4 w-4" />
                </button>
            {:else}
                <button on:click={handleStartTask} class="bg-transparent text-black font-bold py-2 px-2 rounded hover:text-blue-500">
                    <Play class="h-4 w-4" />
                </button>
                <button on:click={handleMarkAsDone} class="bg-transparent text-black font-bold py-2 px-2 rounded hover:text-green-500">
                    <Check class="h-4 w-4" />
                </button>
            {/if}
            <button on:click={() => deleteTask(task.id)} class="bg-transparent text-black font-bold py-2 px-2 rounded hover:text-red-500">
                <Trash2 class="h-4 w-4" />
            </button>
        </div>
    </div>
</div>

================
File: lib/index.ts
================
// place files you want to import through the `$lib` alias in this folder.

================
File: routes/+layout.svelte
================
<script>import "../app.css";</script><slot></slot>

<div>
    <div class="wave"></div>
    <div class="wave"></div>
    <div class="wave"></div>
</div>

================
File: routes/+page.svelte
================
<script lang="ts">
  import { onMount } from "svelte";
  import TaskForm from "$lib/components/TaskForm.svelte";
  import TaskItem from "$lib/components/TaskItem.svelte";
  import ActiveTask from "$lib/components/ActiveTask.svelte";
  import Dropdown from "$lib/components/Dropdown.svelte";

  interface Task {
    name: string;
    duration: number | null;
    id: number;
    description: string;
    status: 'todo' | 'in-progress' | 'paused' | 'done';
    date: string;
  }

  let tasks: Task[] = [];
  let newTask: Task = { name: "", duration: null, id: Date.now(), description: "", status: 'todo', date: new Date().toISOString() }; 
  let activeTask: Task | null = null;
  let timeLeft = 0;
  let isRunning = false;
  let finishedTasks: Task[] = [];
  let filterFinishedTasks: string[] = ['Today', 'This Month', 'All Time'];
  let selectedFilter: string = 'All Time';

  function saveTasks() {
    localStorage.setItem('tasks', JSON.stringify(tasks));
    localStorage.setItem('activeTask', JSON.stringify(activeTask));
    localStorage.setItem('timeLeft', JSON.stringify(timeLeft));
    localStorage.setItem('isRunning', JSON.stringify(isRunning));
    localStorage.setItem('selectedFilter', selectedFilter);
  }

  function loadTasks() {
    const storedTasks = localStorage.getItem('tasks');
    const storedActiveTask = localStorage.getItem('activeTask');
    const storedTimeLeft = localStorage.getItem('timeLeft');
    const storedIsRunning = localStorage.getItem('isRunning');
    const storedSelectedFilter = localStorage.getItem('selectedFilter');

    if (storedTasks) {
      tasks = JSON.parse(storedTasks).map((task: any) => ({
        ...task,
        status: task.status || 'todo',
        date: task.date || new Date().toISOString()
      }));
      sortTasks();
    }

    if (storedActiveTask) {
      activeTask = JSON.parse(storedActiveTask);
    }

    if (storedTimeLeft) {
      timeLeft = JSON.parse(storedTimeLeft);
    }

    if (storedIsRunning) {
      isRunning = JSON.parse(storedIsRunning);
    }

    if (storedSelectedFilter) {
      selectedFilter = JSON.parse(storedSelectedFilter);
    }

    applyFilter(selectedFilter);
  }

  function addTask() {
    if (newTask.name && newTask.duration) {
      tasks = [...tasks, { ...newTask, id: Date.now() }];
      newTask = { name: "", duration: null, id: 0, description: "", status: 'todo', date: new Date().toISOString() };
      sortTasks();
      applyFilter(selectedFilter);
      saveTasks();
    }
  }

  function startTask(task: Task) {
    if (activeTask && activeTask.id !== task.id) {
      return toggleTimer();
    }
    activeTask = task;
    timeLeft = task.status === 'paused' ? timeLeft : (task.duration ? task.duration * 60 : 0);
    isRunning = true;
    task.status = 'in-progress';
    saveTasks();
  }

  function toggleTimer() {
    if (activeTask) {
      isRunning = !isRunning;
      activeTask.status = isRunning ? 'in-progress' : 'paused';
      saveTasks();
    }
  }

  function pauseTask(task: Task) {
    toggleTimer();
  }

  function deleteTask(taskId: number) {
    tasks = tasks.filter(task => task.id !== taskId);
    if (activeTask && activeTask.id === taskId) {
      activeTask = null;
      timeLeft = 0;
      isRunning = false;
    }
    applyFilter(selectedFilter);
    saveTasks();
  }

  function markTaskAsDone(task: Task) {
    task.status = 'done';
    if (activeTask && activeTask.id === task.id) {
      activeTask = null;
      timeLeft = 0;
      isRunning = false;
    }
    sortTasks();
    applyFilter(selectedFilter);
    saveTasks();
  }

  function sortTasks() {
    tasks = tasks.sort((a, b) => {
      if (a.status === 'done' && b.status !== 'done') return 1;
      if (a.status !== 'done' && b.status === 'done') return -1;
      return 0;
    });
  }

  function applyFilter(filter: string) {
    const today = new Date().toISOString().slice(0, 10);
    const doneTasks = tasks.filter(task => task.status === 'done');

    switch (filter) {
      case 'Today':
        finishedTasks = doneTasks.filter(task => task.date.slice(0, 10) === today);
        break;
      case 'This Month':
        finishedTasks = doneTasks.filter(task => task.date.slice(0, 7) === today.slice(0, 7));
        break;
      default: // 'All Time'
        finishedTasks = doneTasks;
    }
    selectedFilter = filter;
  }

  function handleSelect(event: CustomEvent<string>) {
    applyFilter(event.detail);
    saveTasks();
  }

  // New function to export tasks
  function exportTasks() {
    const tasksToExport = JSON.stringify(tasks, null, 2);
    const blob = new Blob([tasksToExport], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'tasks.json';
    a.click();
    URL.revokeObjectURL(url);
  }

  // New function to import tasks
  function importTasks(event: Event) {
    const input = event.target as HTMLInputElement;
    const file = input.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e: ProgressEvent<FileReader>) => {
        const content = e.target?.result as string;
        try {
          const importedTasks = JSON.parse(content);
          tasks = importedTasks.map((task: any) => ({
            ...task,
            status: task.status || 'todo',
            date: task.date || new Date().toISOString()
          }));
          sortTasks();
          applyFilter(selectedFilter);
          saveTasks();
        } catch (error) {
          console.error('Error parsing imported tasks:', error);
          alert('Invalid file format. Please select a valid JSON file.');
        }
      };
      reader.readAsText(file);
    }
  }

  onMount(() => {
    loadTasks();
    let interval: ReturnType<typeof setInterval>;
    return () => {
      if (interval) clearInterval(interval);
    };
  });

  $: if (isRunning && timeLeft > 0) {
    setTimeout(() => {
      timeLeft -= 1;
      if (timeLeft === 0) {
        isRunning = false;
        if (activeTask) {
          activeTask.status = 'done';
          applyFilter(selectedFilter);
        }
        activeTask = null;
      }
      saveTasks();
    }, 1000);
  }
</script>

<style>
  .scrollable {
    max-height: 90vh;
    overflow-y: auto;
    scrollbar-width: none;
  }

  .scrollable::-webkit-scrollbar {
    display: none;
  }
</style>

<div class="container mx-auto p-4 flex gap-6 flex-row">
  <div class="w-full max-w-md">
    <TaskForm {newTask} {addTask} {exportTasks} {importTasks} />
    {#if activeTask}
      <ActiveTask {activeTask} {timeLeft} {isRunning} {toggleTimer} />
    {/if}
  </div>
  <div class="w-full max-w-md">
    <h2 class="text-xl font-bold mb-4">
      Tasks
      <span class="font-light">({tasks.filter(task => task.status !== 'done').reduce((acc, task) => acc + task.duration!, 0)} minutes)</span>
    </h2>
    <div class="scrollable">
      {#each tasks.filter(task => task.status !== 'done') as task (task.id)}
        <TaskItem {task} {startTask} {deleteTask} {markTaskAsDone} {pauseTask} />
      {/each}
      {#if tasks.filter(task => task.status !== 'done').length === 0}
        <div class="text-gray-900 text-sm">No tasks added yet</div>
      {/if}
    </div>
  </div>
  <div class="w-full max-w-md">
    <div class="flex justify-between items-center mb-2">
      <h2 class="text-xl font-bold">
        Finished Tasks
        <span class="font-light">({finishedTasks.reduce((acc, task) => acc + task.duration!, 0)} minutes)</span>
      </h2>
      <Dropdown
        options={filterFinishedTasks}
        selectedOption={selectedFilter}
        on:select={handleSelect}
      />
    </div>
    
    <div class="scrollable">
      {#each finishedTasks as task (task.id)}
        <TaskItem {task} {startTask} {deleteTask} {markTaskAsDone} {pauseTask} />
      {/each}

      {#if finishedTasks.length === 0}
        <div class="text-gray-900 text-sm">No finished tasks yet</div>
      {/if}
    </div>
  </div>
</div>

================
File: app.css
================
@import "tailwindcss/base";
@import "tailwindcss/components";
@import "tailwindcss/utilities";

body {
    margin: auto;
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    overflow: auto;
    background: linear-gradient(315deg, rgb(240, 73, 229) 3%, rgb(72, 157, 243) 38%, rgba(48,238,226,1) 68%, rgb(244, 126, 126) 98%);
    animation: gradient 15s ease infinite;
    background-size: 400% 400%;
    background-attachment: fixed;
}

@keyframes gradient {
    0% {
        background-position: 0% 0%;
    }
    50% {
        background-position: 100% 100%;
    }
    100% {
        background-position: 0% 0%;
    }
}

.wave {
    background: rgb(255 255 255 / 25%);
    border-radius: 0 0 1000% 1000%;
    position: fixed;
    width: 200%;
    height: 20em;
    animation: wave 10s -8s linear infinite;
    transform: translate3d(0, 0, 0);
    opacity: 0.8;
    top: 0;
    left: 0;
    z-index: -1;
}

.wave:nth-of-type(2) {
    top: -1.25em;
    animation: wave 20s linear reverse infinite;
    opacity: 0.8;
}

.wave:nth-of-type(3) {
    top: -2.5em;
    animation: wave 25s -1s reverse infinite;
    opacity: 0.9;
}

@keyframes wave {
    2% {
        transform: translateX(1);
    }

    25% {
        transform: translateX(-25%);
    }

    50% {
        transform: translateX(-50%);
    }

    75% {
        transform: translateX(-25%);
    }

    100% {
        transform: translateX(1);
    }
}

================
File: app.d.ts
================
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};

================
File: app.html
================
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.ico" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover" class="antialiased">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>
